---
layout: post
title: 数据结构-树
date: 2021-02-23 18:49:33
permalink: /pages/0e1041/
sidebar: auto
categories: 
  - 草稿
tags: 
  - 
---

* auto-gen TOC:
{:toc}
# AVL树

定义：

-   AVL树：高度平衡的二叉搜索树（任意节点的两个子树的高度差$\le$ 1）

-   平衡因子：某个节点的左子树高度与右子树高度的差

    因此，AVL树又可作如下定义：任意节点平衡因子的绝对值小于等于1的二叉搜索树



当插入或删除节点导致不平衡时，AVL通过旋转节点来重新平衡节点。



## 旋转时发生了什么

 <img src="./assets/AVL树_1.jpg" style="zoom: 67%;" />

如图，设根节点的左子节点高度为$h_l$，右子节点高度为$h_r$，下面以右旋为例

<img src="./assets/AVL树_2.png" style="zoom: 50%;" />

右旋以后，左子节点的高度为$h'_l$，右子节点高度为$h'_r$，观察可知
$$
\begin{aligned}h'_l&\le h_l - 1\\ h'_r&\le max(h_r+1,h_l)\end{aligned}
$$
显然右旋时，需要根据$h_e$来进行分类讨论。



## 分类讨论

同样以右旋为例

<img src="./assets/AVL树_3.jpg" style="zoom:25%;" />

### LL型

假设插入$f$后使得当前子树$a$失衡，且$h_b=h_d+1$

由于插入前是AVL树，因此$h_e\le h_c$

对$b$进行一次右旋，新的树有$h'_l=h_l-1,h'_r=max(h_e,h_c)+1=h_c+1$

删除操作同理



### LR型

假设插入$f$后使得当前子树$a$失衡，且$h_b=h_e+1$

如果直接右旋，会导致$h'_r=h_e+1>h_r$

因此要先对$e$进行一次左旋，再对$e$进行右旋

删除操作同理



## Java实现及测试代码

```java
package Tree.AVLTree;

import Tree.Tree;
import com.sun.istack.internal.Nullable;

import java.util.ArrayList;
import java.util.List;

public class AVLTree<T extends Comparable<T>> implements Tree<T>{

    private AVLNode<T> root;

    @Override
    public void insert(T value) {
        root = insert(value, root, null);
    }

    @Override
    public void remove(T value) {
        root = remove(value, root);
    }

    @Override
    public List<T> travel() {
        ArrayList<T> result = new ArrayList<>();
        travel(result, root);
        return result;
    }

    private AVLNode<T> insert(T value, AVLNode<T> node, AVLNode<T> parent){
        if(node == null) return new AVLNode<>(value, null, null, parent);
        if(node.value.compareTo(value) == 0) return node;

        int dir = node.value.compareTo(value) > 0 ? 0: 1;
        node.child[dir] = insert(value, node.child[dir], node);
        node.updateHeight();
        return rebalance(node);
    }

    private AVLNode<T> remove(T value, AVLNode<T> node){
        if(node == null) return null;
        if(node.value.compareTo(value) == 0){
            // 没有子节点
            if(node.child[0] == null && node.child[1] == null) return null;

            // 只有一个子节点
            if(node.child[0] == null || node.child[1] == null){
                int notNullIdx = node.child[0] == null ? 1 : 0; // 子节点方向
                node.child[notNullIdx].parent = node.parent;
                return node.child[notNullIdx];
            }

            // 有两个子节点，先按常规BST的方法删除
            AVLNode<T> least = node.child[1];
            while(least.child[0] != null) least = least.child[0];
            node.value = least.value;
            least.parent.child[getChildDir(least)] = least.child[1];
            if(least.child[1] != null) least.child[1].parent = least.parent;
            least.parent.updateHeight();
            // 从least节点开始，一直向上rebalance
            AVLNode<T> current = least.parent;
            while(current != node){
                current.updateHeight();
                current = rebalance(current).parent;
            }
            return rebalance(node);

        } else {
            int dir = node.value.compareTo(value) > 0 ? 0 : 1;
            node.child[dir] = remove(value, node.child[dir]);
            node.updateHeight();
            return rebalance(node);
        }
    }

    /**
     * 对节点进行再平衡
     */
    private AVLNode<T> rebalance(AVLNode<T> node){
        // dir: 重子树（高度更高的子树）相对于父节点的方向
        int dir = height(node.child[0]) > height(node.child[1]) ? 0 : 1;
        int heavy = height(node.child[dir]);
        int light = height(node.child[dir ^ 1]);
        if(Math.abs(heavy - light) >= 2){
            if(height(node.child[dir].child[dir]) > height(node.child[dir].child[dir ^ 1])){
                return rotate(node.child[dir]); // LL 或 RR
            }else{ // LR 或 RL
                AVLNode<T> n = node.child[dir].child[dir ^ 1];
                return rotate(rotate(n));
            }
        }
        return node;
    }

    /**
     * 将节点左旋（或右旋）
     */
    private AVLNode<T> rotate(AVLNode<T> node){
        if(node == root) throw new IllegalStateException("不能旋转根节点");

        AVLNode<T> parent = node.parent;
        AVLNode<T> grandParent = parent == null ? null : parent.parent;
        int direction = getChildDir(node);

        node.parent = grandParent;
        if(grandParent != null) grandParent.child[getChildDir(parent)] = node;
        parent.child[direction] = node.child[direction ^ 1];
        if(node.child[direction ^ 1] != null) parent.child[direction].parent = parent;
        node.child[direction ^ 1] = parent;
        parent.parent = node;

        parent.updateHeight();
        node.updateHeight();

        if(node.parent == null) root = node;
        return node;
    }

    /**
     * 获取当前节点对于父节点的方向
     * @return 如果当前节点为父节点的左子节点，则返回0，否则返回1
     */
    private int getChildDir(AVLNode<T> node){
        if(node.parent == null) throw new IllegalStateException("不能对根节点调用getDir");
        return node.parent.child[0] == node ? 0 : 1;
    }

    /**
     * 中序遍历二叉树
     */
    private void travel(List<T> result, AVLNode<T> node){
        if(node != null){
            travel(result, node.child[0]);
            result.add(node.value);
            travel(result, node.child[1]);
        }
    }

    public static int height(AVLNode<?> node){
        return node == null ? 0 : node.height;
    }

    private static class AVLNode<T> {
        public int height = 1;
        public AVLNode<T>  parent;
        public AVLNode<T>[] child = new AVLNode[2];
        public T value;

        public AVLNode(T v, @Nullable AVLNode<T> left, @Nullable AVLNode<T> right, @Nullable AVLNode<T> parent){
            value = v;
            child[0] = left;
            child[1] = right;
            this.parent = parent;
            updateHeight();
        }

        public void updateHeight(){
            height = Math.max(height(child[0]), height(child[1])) + 1;
        }
    }

}
```





测试代码

输出：`time: 20.106 s`

```java
package Tree;

import Tree.AVLTree.AVLTree;

import java.util.*;

public class Main {

    private static final int TEST_LENGTH = 1000000;

    public static void main(String[] args) {

        for(int i=0; i<10; i++){
            if(!judge(Util.generateRandomNumber(TEST_LENGTH, 1, 10000000)))
                System.out.println("err on " + i);
        }

        long begin = System.currentTimeMillis();
        for(int i=0; i<10; i++){
            speedTest(Util.generateSortedNumber(TEST_LENGTH, 1));
            speedTest(Util.generateRandomNumber(TEST_LENGTH, 1, 10000000));
        }
        long end = System.currentTimeMillis();
        System.out.println("time : " + (end - begin) / 1000. + " s");

    }

    private static void speedTest(List<Integer> data) {
        AVLTree<Integer> tree = new AVLTree<>();
        for(int v: data) tree.insert(v);
        Random ran = new Random();

        for(int i=0; i<TEST_LENGTH * 0.3; i++){
            int v = data.get(ran.nextInt(data.size()));
            tree.remove(v);
        }
    }

    private static boolean judge(List<Integer> data){
        AVLTree<Integer> tree = new AVLTree<>();
        Set<Integer> groundTrue = new TreeSet<>();
        for(int v: data){
            tree.insert(v);
            groundTrue.add(v);
        }

        Random ran = new Random();
        for(int i=0; i<TEST_LENGTH * 0.3; i++){
            int v = data.get(ran.nextInt(data.size()));
            groundTrue.remove(v);
            tree.remove(v);
        }

        List<Integer> resultOfTree = tree.travel();
        Iterator<Integer> it = groundTrue.iterator();
        for(int v: resultOfTree) {
            if(it.next() != v) return false;
        }
        return true;
    }

}
```



## 疑问

AVL树插入时，最多有多少个节点失衡？删除呢？



# 红黑树



# B树



# B+树

