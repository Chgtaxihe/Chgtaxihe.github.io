(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{617:function(a,s,t){a.exports=t.p+"assets/img/class文件结构_1.47577d77.jpg"},618:function(a,s,t){a.exports=t.p+"assets/img/常量池_1.03e20fee.jpg"},755:function(a,s,t){"use strict";t.r(s);var v=t(30),_=Object(v.a)({},(function(){var a=this,s=a.$createElement,v=a._self._c||s;return v("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[v("h2",{attrs:{id:"第二章-java内存区域与内存溢出异常"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#第二章-java内存区域与内存溢出异常"}},[a._v("#")]),a._v(" 第二章：Java内存区域与内存溢出异常")]),a._v(" "),v("h3",{attrs:{id:"运行时内存区域-run-time-data-areas"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#运行时内存区域-run-time-data-areas"}},[a._v("#")]),a._v(" 运行时内存区域（Run-Time Data Areas）")]),a._v(" "),v("ol",[v("li",[v("p",[a._v("程序计数器PC register (jvms: 2.5.1)：")]),a._v(" "),v("p",[v("strong",[a._v("每个")]),a._v('JVM线程均持有一个PC，类似于CPU中的PC寄存器，但需要注意的是，尽管JVMS中将其称为"pc register"，且CPU中通常也有多个PC'),v("a",{attrs:{href:"%E5%A4%9A%E6%A0%B8CPU%E4%B8%AD%E6%AF%8F%E4%B8%AA%E6%A0%B8%E5%9D%87%E6%9C%89%E7%8B%AC%E7%AB%8B%E7%9A%84%E4%B8%80%E5%A5%97%E5%AF%84%E5%AD%98%E5%99%A8%E3%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E3%80%81TLB%E3%80%81L1L2%E7%BC%93%E5%AD%98%E3%80%82"}},[a._v("^2-1")]),a._v("，但两者并不是一回事，JVM的PC存放在内存中。")])]),a._v(" "),v("li",[v("p",[a._v("JVM栈Java Virtual Machine Stacks (jvms: 2.5.2)")]),a._v(" "),v("p",[v("strong",[a._v("每个")]),a._v("JVM线程都有自己"),v("strong",[a._v("私有")]),a._v("的JVM栈。类似于C++等语言，每个方法被执行时，就会同步创建一个"),v("strong",[a._v("栈帧")]),a._v("(Stack Frame)，用于保存局部变量表、操作数栈、动态连接、方法出口等")]),a._v(" "),v("p",[a._v("每个方法的局部变量表所占用的空间（槽数，Slot）在编译时确定，在运行时不会改变")]),a._v(" "),v("p",[a._v("此区域可能抛出的异常")]),a._v(" "),v("ul",[v("li",[a._v("StackOverflowError: 栈深超过允许范围")]),a._v(" "),v("li",[a._v("OutOfMemoryError: 若栈允许动态拓展，且无法在拓展时抛出（HotSpot不允许动态拓展栈容量）")])])]),a._v(" "),v("li",[v("p",[a._v("Native Method Stacks (jvms: 2.5.6)")]),a._v(" "),v("p",[a._v("类似于JVM stacks")])]),a._v(" "),v("li",[v("p",[a._v("Java堆Heap (jvms: 2.5.3)")]),a._v(" "),v("p",[a._v("Java堆由所有JVM线程"),v("strong",[a._v("共享")]),a._v("，在不考虑JVM优化的情况下，所有对象实例以及数组均在堆上分配")]),a._v(" "),v("p",[a._v("Java堆既可以固定大小，也可以动态拓展（或缩小）")]),a._v(" "),v("p",[a._v("此区域可能抛出的异常")]),a._v(" "),v("ul",[v("li",[a._v("OutOfMemoryError: 当新的对象无法分配到足够的内存时，抛出此异常")])])]),a._v(" "),v("li",[v("p",[a._v("方法区Method Areas (jvms: 2.5.4)")]),a._v(" "),v("p",[a._v("由JVM所有线程"),v("strong",[a._v("共享")]),a._v("，逻辑上是Java堆的一部分；在JDK6及以前的HostSpot中，该区域保存在Java堆的永久代中，JDK8废弃永久代后，该区域保存于在本地内存的元空间(Meta-space)中。该区域保存JVM加载的类型信息、常量、静态变量、JIT编译后的代码缓存等，此区域允许不实现垃圾回收")]),a._v(" "),v("p",[a._v("此区域可能抛出的异常")]),a._v(" "),v("ul",[v("li",[a._v("OutOfMemoryError: 无法分配到足够的内存时，抛出此异常")])])]),a._v(" "),v("li",[v("p",[a._v("运行时常量池Run-Time Constant Pool (jvms: 2.5.5)")]),a._v(" "),v("p",[a._v("方法区的一部分，用于保存Class文件的常量池表，存放编译器生成的各种字面量与符号引用；同时，运行时也可以将新产生的常量放入其中")])]),a._v(" "),v("li",[v("p",[a._v("直接内存")]),a._v(" "),v("p",[a._v("并非JVMS中规定的内存区域")]),a._v(" "),v("p",[a._v("例如在NIO中，使用了Native函数直接分配"),v("strong",[a._v("堆外")]),a._v("内存，以此提高性能，避免在Java堆和Native堆中来回复制数据")]),a._v(" "),v("p",[a._v("此区域不受Java堆大小上限控制")])])]),a._v(" "),v("h3",{attrs:{id:"hostspot虚拟机中的对象"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#hostspot虚拟机中的对象"}},[a._v("#")]),a._v(" HostSpot虚拟机中的对象")]),a._v(" "),v("h4",{attrs:{id:"创建对象"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#创建对象"}},[a._v("#")]),a._v(" 创建对象")]),a._v(" "),v("p",[a._v("当创建一个普通的Java对象时，首先JVM会检查能否在常量池中定位到这个类的符号引用，并检查引用代表的类是否被加载（若没有，则执行加载操作）")]),a._v(" "),v("p",[a._v("随后，JVM将为对象分配内存（所需内存大小在加载时即可确认）；寻找可用内存时，可以有两种方法：")]),a._v(" "),v("ol",[v("li",[a._v("“Bump the Pointer”，即如同栈一样，将空闲指针后移一段距离")]),a._v(" "),v("li",[a._v("维护一个空闲列表，在列表中查找可用空间")])]),a._v(" "),v("p",[a._v("在并发情况下，即使是修改指针位置也不是线程安全的，为了减少加锁次数，有两种解决方案")]),a._v(" "),v("ol",[v("li",[v("p",[a._v("CAS(Compare and Swap)并重试：")]),a._v(" "),v("p",[a._v("采用CPU的CAS指令"),v("a",{attrs:{href:"%E5%A6%82%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4cmpxchg"}},[a._v("^2-2")]),a._v("来实现原子操作（若失败则继续重试直至成功）")])]),a._v(" "),v("li",[v("p",[a._v("TLAB(Thread Local Allocation Buffer)：")]),a._v(" "),v("p",[a._v("每个线程在Java堆中先分配一小块内存，线程分配内存时，在本地缓冲区中分配，仅当缓冲区空间用尽，分配新的缓冲区时才需要加锁")])])]),a._v(" "),v("p",[a._v("分配完成后，需要对分配空间初始化为0值")]),a._v(" "),v("p",[a._v("随后，还需要设置对象的"),v("code",[a._v("对象头")]),a._v("，其中包含：")]),a._v(" "),v("ol",[v("li",[a._v("GC分带年龄、锁状态、线程持有的锁等")]),a._v(" "),v("li",[a._v("如果通过直接指针访问对象，则需要保存类型指针")]),a._v(" "),v("li",[a._v("如果是数组，则还需保存数组长度")])]),a._v(" "),v("p",[a._v("接下来，如果有需要的话，将执行对象的构造函数")]),a._v(" "),v("h4",{attrs:{id:"引用对象"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#引用对象"}},[a._v("#")]),a._v(" 引用对象")]),a._v(" "),v("p",[a._v("对象的访问方式由JVM实现而定，通常有2种方式")]),a._v(" "),v("ol",[v("li",[a._v("引用中保存对象的句柄地址：Java堆中可能会划分出一块作为句柄池，其中保存对象到实例数据、类型数据的指针。当移动对象时，只需改变实例数据指针，无需改变引用")]),a._v(" "),v("li",[a._v("引用中保存直接指针：引用直接持有对象地址，访问速度更快，但移动对象时需要修改栈中的引用")])]),a._v(" "),v("h2",{attrs:{id:"第三章-垃圾收集器与内存分配策略"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#第三章-垃圾收集器与内存分配策略"}},[a._v("#")]),a._v(" 第三章：垃圾收集器与内存分配策略")]),a._v(" "),v("h3",{attrs:{id:"对象死亡判定"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#对象死亡判定"}},[a._v("#")]),a._v(" 对象死亡判定")]),a._v(" "),v("h4",{attrs:{id:"引用计数算法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#引用计数算法"}},[a._v("#")]),a._v(" 引用计数算法")]),a._v(" "),v("p",[a._v("简单高效但不完整的算法")]),a._v(" "),v("p",[a._v("当被引用时，引用计数器加一；引用消失时，引用计数器减一；引用计数器归零的对象就是不可能再被使用的")]),a._v(" "),v("p",[a._v("当对象之间发生相互循环引用问题时，简单地引用计数无法将其回收，需要使用额外的算法")]),a._v(" "),v("h4",{attrs:{id:"可达性分析"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#可达性分析"}},[a._v("#")]),a._v(" 可达性分析")]),a._v(" "),v("p",[a._v("从“GC Root”根节点出发，以引用关系为边（成为引用链），能到达的节点即为存活。")]),a._v(" "),v("p",[a._v("在Java中，固定可作为GC Root的对象有：")]),a._v(" "),v("ul",[v("li",[a._v("虚拟机栈中引用的对象（局部变量等）")]),a._v(" "),v("li",[a._v("本地方法栈中引用的对象")]),a._v(" "),v("li",[a._v("方法区中类静态(static)属性引用")]),a._v(" "),v("li",[a._v("方法区中的常量引用对象（如字符常量池中的引用）")]),a._v(" "),v("li",[a._v("JVM内部的引用，如基本数据类型的Class对象，常驻的异常、系统类加载器等")]),a._v(" "),v("li",[a._v("被同步锁持有的对象")]),a._v(" "),v("li",[a._v("反应JVM内部情况的JMXBean、本地代码缓存等")])]),a._v(" "),v("p",[a._v("此外，JVM还可以临时性的将其他对象加入GC Root")]),a._v(" "),v("h4",{attrs:{id:"引用类型"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#引用类型"}},[a._v("#")]),a._v(" 引用类型")]),a._v(" "),v("p",[a._v("Java 1.2以后，引用被分为了4类")]),a._v(" "),v("ul",[v("li",[a._v("强引用(Strongly Reference)：类似于"),v("code",[a._v("Object obj = new Object()")]),a._v("的引用关系，在任何情况下，只要强引用存在，GC就不会回收被引用的对象")]),a._v(" "),v("li",[a._v("软引用(Soft Reference)：只被软引用关联的对象，在将要发生"),v("strong",[a._v("内存溢出异常")]),a._v("前（内存不足时），会把这些对象列入回收范围中进行"),v("strong",[a._v("第二次回收")]),a._v("，若内存仍然不够，抛出内存溢出异常")]),a._v(" "),v("li",[a._v("弱引用(Weak Referencee)：只被弱引用关联的对象，只能生存到下一次垃圾收集前。当垃圾收集器发现一个只具有弱引用的对象时，无论内存是否充足都会回收该对象")]),a._v(" "),v("li",[a._v("虚引用(PhantomReference)：一个对象是否有虚引用不影响其生存周期，也"),v("strong",[a._v("无法通过虚引用获取对象实例")]),a._v("，唯一作用在于该对象被垃圾收集器回收时会收到一个"),v("strong",[a._v("通知")]),a._v("（所以只能配合弱引用、软引用使用？）")])]),a._v(" "),v("h4",{attrs:{id:"回收方法区"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#回收方法区"}},[a._v("#")]),a._v(" 回收方法区")]),a._v(" "),v("p",[a._v("主要包含：废弃的常量、不再使用的类型")]),a._v(" "),v("p",[a._v("判断常量是否废弃类似于堆中的对象")]),a._v(" "),v("p",[a._v("判断类型是否废弃则比较苛刻，需要满足以下条件")]),a._v(" "),v("ul",[v("li",[a._v("该类的所有实例都已经被回收")]),a._v(" "),v("li",[a._v("该类对应的Class对象没有在任何地方被引用")]),a._v(" "),v("li",[a._v("加载该类的类加载器已被回收（很难达成）")])]),a._v(" "),v("h3",{attrs:{id:"垃圾回收算法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收算法"}},[a._v("#")]),a._v(" 垃圾回收算法")]),a._v(" "),v("h4",{attrs:{id:"分代收集"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#分代收集"}},[a._v("#")]),a._v(" 分代收集")]),a._v(" "),v("p",[a._v("基于两个假说")]),a._v(" "),v("ul",[v("li",[a._v("弱分代假说：绝大多数对象都是很快死亡的")]),a._v(" "),v("li",[a._v("强分代假说：熬过越多次垃圾收集过程的对象就越难以死亡")])]),a._v(" "),v("p",[a._v("这两个假说导出一个结论：收集器应当将堆划分为不同区域，并依据对象的年龄将其分配到不同区域中储存")]),a._v(" "),v("p",[a._v("然而，当需要针对某一代进行垃圾收集时，可能存在跨代引用的情况：如对新生代进行垃圾收集时，可能存在老年代对新生代的引用，为此不得不将整个老年代加入到GC Root中（额外遍历了整个老年代）以保证结果的正确性")]),a._v(" "),v("p",[a._v("为了解决上述问题，这里需要引入第三个假说")]),a._v(" "),v("ul",[v("li",[a._v("跨代引用相对于同代引用来说只占极少数")])]),a._v(" "),v("p",[a._v("根据上述假说，我们不再需要为了少数的跨代引用而遍历整个老年代，只需建立一个数据结构（成为Remembered Set），将老年代划分为若干个小块，并表示出那一块会存在跨代引用；当对新生代进行收集时，只需将存在跨代引用的块内对象加入GC Root即可")]),a._v(" "),v("h4",{attrs:{id:"标记-清除算法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#标记-清除算法"}},[a._v("#")]),a._v(" 标记-清除算法")]),a._v(" "),v("p",[a._v("首先标记处所有需要回收的对象，标记完成后，统一回收掉所有被标记的对象")]),a._v(" "),v("p",[a._v("存在2个缺点")]),a._v(" "),v("ul",[v("li",[a._v("执行效率不稳定（随堆大小增长而线性增长）")]),a._v(" "),v("li",[a._v("内存空间碎片化")])]),a._v(" "),v("h4",{attrs:{id:"标记-复制算法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#标记-复制算法"}},[a._v("#")]),a._v(" 标记-复制算法")]),a._v(" "),v("p",[a._v("将可用内存划分为大小相等的两块，每次只使用其中一块。当发生垃圾收集时，将存活对象复制到另一个块中，并将当前块清空。")]),a._v(" "),v("p",[a._v("大多数JVM都采用了这种算法去回收新生代，称为“Appel式回收”，具体做法是：")]),a._v(" "),v("p",[a._v("将新生代划分为一块较大的"),v("code",[a._v("Eden")]),a._v("空间和两块较小的"),v("code",[a._v("Survivor")]),a._v("空间，每次分配内存时只使用"),v("code",[a._v("Eden")]),a._v("和一块"),v("code",[a._v("Survivor")]),a._v("，当发生GC时，将其中存活的对象复制到另一块"),v("code",[a._v("Survivor")]),a._v("中，并直接清理"),v("code",[a._v("Eden")]),a._v("和旧的"),v("code",[a._v("Survivor")]),a._v("（HotSpot中"),v("code",[a._v("Eden")]),a._v("和"),v("code",[a._v("Survivor")]),a._v("的大小比例是8:1）")]),a._v(" "),v("p",[a._v("当"),v("code",[a._v("Survivor")]),a._v("不足以容纳存活的对象时，需要依赖其他区域来进行分配：多出来的对象直接进入老年代")]),a._v(" "),v("h4",{attrs:{id:"标记-整理算法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#标记-整理算法"}},[a._v("#")]),a._v(" 标记-整理算法")]),a._v(" "),v("p",[a._v("当对象存活率较高时，标记-复制算法效率不高，且标记复制算法需要额外空间进行担保，所以老年代不能选择该算法")]),a._v(" "),v("p",[a._v("标记-整理算法具体操作为：标记存活对象，随后让存活对象都向内存空间一段移动，最后清理边界外内存")]),a._v(" "),v("p",[a._v("进行整理操作的缺点在于，必须暂停用户程序才能进行；然而若是采用标记-清除算法，空间碎片化的问题只能依靠复杂的内存分配器来解决（如维护空闲列表）")]),a._v(" "),v("h3",{attrs:{id:"hotspot的算法细节"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#hotspot的算法细节"}},[a._v("#")]),a._v(" HotSpot的算法细节")]),a._v(" "),v("h4",{attrs:{id:"准确式内存管理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#准确式内存管理"}},[a._v("#")]),a._v(" 准确式内存管理")]),a._v(" "),v("p",[a._v("VM可以知道内存中（栈和堆包括在其中）某个位置的数据具体是什么类型，比如对于一个4字节的整数，虚拟机可以区分出它到底是一个int还是一个内存地址")]),a._v(" "),v("p",[a._v("此外，还有保守式和半保守式（根上保守）")]),a._v(" "),v("p",[a._v("推荐阅读：https://www.cnblogs.com/strinkbug/p/6376525.html")]),a._v(" "),v("h4",{attrs:{id:"从根节点枚举"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#从根节点枚举"}},[a._v("#")]),a._v(" 从根节点枚举")]),a._v(" "),v("p",[a._v("由于HotSpot采用准确式内存管理，使用一组"),v("code",[a._v("OopMap")]),a._v("来保存对象某个偏移量上是什么类型的数据，即可以知道哪些位置保存的是引用，因而不必像保守式GC一样扫描所有数字"),v("a",{attrs:{href:"%E6%AD%A4%E5%A4%84%E5%AD%98%E7%96%91"}},[a._v("^3-1")])]),a._v(" "),v("h4",{attrs:{id:"安全点、安全区域"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#安全点、安全区域"}},[a._v("#")]),a._v(" 安全点、安全区域 *")]),a._v(" "),v("p",[a._v("这部分未能理解，日后补上")]),a._v(" "),v("h4",{attrs:{id:"记忆集、卡表与写屏障"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#记忆集、卡表与写屏障"}},[a._v("#")]),a._v(" 记忆集、卡表与写屏障")]),a._v(" "),v("p",[a._v("上文提到，分代收集时需要借助记忆集(Remembered Set)来记录跨代引用")]),a._v(" "),v("p",[a._v("HotSpot中将内存划分为一个个特定大小的块，称为卡页；同时使用一个字节数组来表示内存区域中的卡内是否存在跨代指针，称为卡表")]),a._v(" "),v("p",[a._v("当卡页内有一个或多个对象内存在跨代指针，那么卡表内对应元素的值标识为1，成为这个元素变脏(dirty)。")]),a._v(" "),v("div",{staticClass:"language- line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("CARD_TABLE [this address >> 9] = 1;\n")])]),a._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[a._v("1")]),v("br")])]),v("p",[a._v("在GC时，只需从变脏的卡页中得到跨代指针，加入GC Roots中即可")]),a._v(" "),v("p",[a._v("每当引用发生改变，就可能产生新的脏卡页，因此在每个赋值语句后，都应当插入更新卡表的操作，HotSpot中采用写屏障（类似与AOP）来解决该问题：虚拟机会自动为所有赋值操作生成对应的更新卡表指令"),v("a",{attrs:{href:"%E5%9C%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%8E%AF%E5%A2%83%E4%B8%8B%EF%BC%8C%E5%8D%A1%E8%A1%A8%E8%BF%98%E5%AD%98%E5%9C%A8%E2%80%9C%E4%BC%AA%E5%85%B1%E4%BA%AB%E2%80%9D%E9%97%AE%E9%A2%98"}},[a._v("^3-2")])]),a._v(" "),v("h5",{attrs:{id:"小问题"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#小问题"}},[a._v("#")]),a._v(" 小问题 *")]),a._v(" "),v("p",[a._v("读到这里我有一个疑惑：书中并没有介绍卡页变脏后是否存在机会变“干净”，若只使用上文中提到的数组，那么当脏卡页内"),v("strong",[a._v("不再")]),a._v("存在跨代指针时，没有足够的信息（除非再扫描一遍）将其变“干净”。")]),a._v(" "),v("p",[a._v("虚拟机中是否有某些机制能够避免在扫描一遍的浪费（比如计数）？")]),a._v(" "),v("h4",{attrs:{id:"并发的可达性分析"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#并发的可达性分析"}},[a._v("#")]),a._v(" 并发的可达性分析")]),a._v(" "),v("p",[a._v("我们将可达性分析过程中的对象分为三类")]),a._v(" "),v("ol",[v("li",[a._v("未被访问")]),a._v(" "),v("li",[a._v("已被访问")]),a._v(" "),v("li",[a._v("正在被访问（对象内至少有一个引用还未被扫描）")])]),a._v(" "),v("p",[a._v("若是在可达性分析的过程中，对象的引用关系发生了变化，则有可能导致以下结果")]),a._v(" "),v("ul",[v("li",[a._v("本应死亡的对象被标记为存活（不破坏程序正常运行，不予处理）")]),a._v(" "),v("li",[a._v("本应存活的对象被标记为死亡（对象消失）")])]),a._v(" "),v("p",[a._v("当且仅当以下条件同时满足时，会产生对象消失问题：")]),a._v(" "),v("ol",[v("li",[v("p",[a._v("插入了一条或多条从已被访问对象到未被访问对象的引用")]),a._v(" "),v("p",[a._v("为了破坏此条件，当插入从已访问指向未访问对象的引用时，将其记录下来，扫描结束后从这些已访问对象开始再扫描一遍。可理解为，当新的引用插入时，已访问对象将变为为访问对象（或未被完全扫描的对象）")])]),a._v(" "),v("li",[v("p",[a._v("删除了全部从正在被访问到该未被访问对象的引用")]),a._v(" "),v("p",[a._v("为破坏此条件，删除从正在访问对象到未被访问对象的引用时，将其记录下来，扫描结束后在根据这些记录扫描一遍。可理解为：无论删除与否，只根据开始扫描那一刻的引用关系来搜索。")])])]),a._v(" "),v("p",[a._v('注意：重新扫描的过程可能需要"Stop the World"（如CMS中重新标记过程）')]),a._v(" "),v("h3",{attrs:{id:"各类垃圾收集器简介"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#各类垃圾收集器简介"}},[a._v("#")]),a._v(" 各类垃圾收集器简介 *")]),a._v(" "),v("p",[a._v("一阅未能理解，不整理笔记，日后补充")]),a._v(" "),v("h2",{attrs:{id:"第七章-虚拟机类加载机制"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#第七章-虚拟机类加载机制"}},[a._v("#")]),a._v(" 第七章：虚拟机类加载机制")]),a._v(" "),v("p",[a._v("一个类在使用前需要经历：")]),a._v(" "),v("ol",[v("li",[v("p",[a._v("加载（Loading）")])]),a._v(" "),v("li",[v("p",[a._v("链接（Linking）")]),a._v(" "),v("p",[a._v("链接被分为3部分")]),a._v(" "),v("ol",[v("li",[v("p",[a._v("验证（Verification）")])]),a._v(" "),v("li",[v("p",[a._v("准备（Preparation）")])]),a._v(" "),v("li",[v("p",[a._v("解析（Resolution）：")]),a._v(" "),v("p",[a._v("解析比较特殊，允许发生在初始化之后")])])])]),a._v(" "),v("li",[v("p",[a._v("初始化（Initialization）")])])]),a._v(" "),v("h3",{attrs:{id:"类初始化的时机"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#类初始化的时机"}},[a._v("#")]),a._v(" 类初始化的时机")]),a._v(" "),v("p",[a._v("JVMS规定只有以下六种情况才会初始化一个类")]),a._v(" "),v("ul",[v("li",[a._v("触发"),v("code",[a._v("new")]),a._v("/"),v("code",[a._v("getstatic")]),a._v("/"),v("code",[a._v("putstatic")]),a._v("/"),v("code",[a._v("invokestatic")]),a._v("四条字节码时")]),a._v(" "),v("li",[a._v("使用反射调用对应类时")]),a._v(" "),v("li",[a._v("自身作为父类，且子类需要初始化时")]),a._v(" "),v("li",[a._v("虚拟机启动时，需要执行的主类（main入口函数那个类）")]),a._v(" "),v("li",[a._v("当接口中定义了默认方法（default），该接口的实现类进行初始化时，该接口需要先进行初始化")]),a._v(" "),v("li",[a._v("The first invocation of a java.lang.invoke.MethodHandle instance which\nwas the result of method handle resolution for a method handle\nof kind 2 (REF_getStatic), 4 (REF_putStatic), 6 (REF_invokeStatic), or 8\n(REF_newInvokeSpecial).")])]),a._v(" "),v("p",[a._v("需要注意的是：")]),a._v(" "),v("ol",[v("li",[v("p",[a._v("通过子类引用父类的静态字段，只会初始化父类（即只初始化定义对应字段的类）")])]),a._v(" "),v("li",[v("p",[a._v("通过数组定义来引用类，不会触发此类的初始化 *")])]),a._v(" "),v("li",[v("p",[a._v("常量（static final）进入常量池，因而不会触发定义常量的类初始化")])]),a._v(" "),v("li",[v("p",[a._v("当类继承了接口且接口没有"),v("code",[a._v("default")]),a._v("方法时，不会初始化该接口")]),a._v(" "),v("div",{staticClass:"language-java line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-java"}},[v("code",[v("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),v("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("interface")]),a._v(" "),v("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("IClass")]),a._v(" "),v("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n\n    "),v("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("static")]),a._v(" "),v("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" val "),v("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),v("span",{pre:!0,attrs:{class:"token function"}},[a._v("run")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n\n    "),v("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("static")]),a._v(" "),v("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" "),v("span",{pre:!0,attrs:{class:"token function"}},[a._v("run")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n        "),v("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("System")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("out"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),v("span",{pre:!0,attrs:{class:"token function"}},[a._v("println")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),v("span",{pre:!0,attrs:{class:"token string"}},[a._v('"init"')]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n        "),v("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("return")]),a._v(" "),v("span",{pre:!0,attrs:{class:"token number"}},[a._v("0")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    "),v("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n\n    "),v("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// default void initMe(){}")]),a._v("\n"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n\n"),v("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),v("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("class")]),a._v(" "),v("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Klass")]),a._v(" "),v("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("implements")]),a._v(" "),v("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("IClass")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n\n"),v("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),v("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("class")]),a._v(" "),v("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("InitOfInterface")]),a._v(" "),v("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n\n    "),v("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),v("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("static")]),a._v(" "),v("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("void")]),a._v(" "),v("span",{pre:!0,attrs:{class:"token function"}},[a._v("main")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),v("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("String")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v(" args"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),v("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n        "),v("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Klass")]),a._v(" klass "),v("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),v("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("new")]),a._v(" "),v("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Klass")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n        "),v("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("System")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("out"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),v("span",{pre:!0,attrs:{class:"token function"}},[a._v("println")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),v("span",{pre:!0,attrs:{class:"token string"}},[a._v('"new Klass"')]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n        "),v("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("System")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("out"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),v("span",{pre:!0,attrs:{class:"token function"}},[a._v("println")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),v("span",{pre:!0,attrs:{class:"token string"}},[a._v('"klass.val: "')]),a._v(" "),v("span",{pre:!0,attrs:{class:"token operator"}},[a._v("+")]),a._v(" klass"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("val"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    "),v("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n\n"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n"),v("span",{pre:!0,attrs:{class:"token comment"}},[a._v("/* 注释第10行后输出:\nnew Klass\ninit\nklass.val: 0\n*/")]),a._v("\n")])]),a._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[a._v("1")]),v("br"),v("span",{staticClass:"line-number"},[a._v("2")]),v("br"),v("span",{staticClass:"line-number"},[a._v("3")]),v("br"),v("span",{staticClass:"line-number"},[a._v("4")]),v("br"),v("span",{staticClass:"line-number"},[a._v("5")]),v("br"),v("span",{staticClass:"line-number"},[a._v("6")]),v("br"),v("span",{staticClass:"line-number"},[a._v("7")]),v("br"),v("span",{staticClass:"line-number"},[a._v("8")]),v("br"),v("span",{staticClass:"line-number"},[a._v("9")]),v("br"),v("span",{staticClass:"line-number"},[a._v("10")]),v("br"),v("span",{staticClass:"line-number"},[a._v("11")]),v("br"),v("span",{staticClass:"line-number"},[a._v("12")]),v("br"),v("span",{staticClass:"line-number"},[a._v("13")]),v("br"),v("span",{staticClass:"line-number"},[a._v("14")]),v("br"),v("span",{staticClass:"line-number"},[a._v("15")]),v("br"),v("span",{staticClass:"line-number"},[a._v("16")]),v("br"),v("span",{staticClass:"line-number"},[a._v("17")]),v("br"),v("span",{staticClass:"line-number"},[a._v("18")]),v("br"),v("span",{staticClass:"line-number"},[a._v("19")]),v("br"),v("span",{staticClass:"line-number"},[a._v("20")]),v("br"),v("span",{staticClass:"line-number"},[a._v("21")]),v("br"),v("span",{staticClass:"line-number"},[a._v("22")]),v("br"),v("span",{staticClass:"line-number"},[a._v("23")]),v("br"),v("span",{staticClass:"line-number"},[a._v("24")]),v("br"),v("span",{staticClass:"line-number"},[a._v("25")]),v("br"),v("span",{staticClass:"line-number"},[a._v("26")]),v("br"),v("span",{staticClass:"line-number"},[a._v("27")]),v("br"),v("span",{staticClass:"line-number"},[a._v("28")]),v("br")])])])]),a._v(" "),v("h3",{attrs:{id:"类加载过程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#类加载过程"}},[a._v("#")]),a._v(" 类加载过程 *")]),a._v(" "),v("p",[a._v("因为一些特殊的原因（计划被打乱了），此节暂时跳过")]),a._v(" "),v("h3",{attrs:{id:"类加载器"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#类加载器"}},[a._v("#")]),a._v(" 类加载器 *")]),a._v(" "),v("p",[a._v("类加载器负责实现类的加载，每个Java类在VM中的唯一性由"),v("strong",[a._v("其类加载器与这个类本身")]),a._v("共同确定")]),a._v(" "),v("p",[a._v("JDK 8及更低版本中有着三层类加载器、双亲委派的类加载结构")]),a._v(" "),v("ol",[v("li",[a._v("Bootstrap Class Loader：")]),a._v(" "),v("li",[a._v("Extension Class Loader：")]),a._v(" "),v("li",[a._v("Application Class Loader：")])]),a._v(" "),v("p",[a._v("双亲委派模型：")]),a._v(" "),v("p",[a._v("​\t如果一个类收到了类加载请求，会首先将请求委派给父类加载器，若父类加载器无法完成加载，才会尝试自己完成。这就保证了在各类加载器环境下，加载出的类（比如Object等）都是同一个。")]),a._v(" "),v("h4",{attrs:{id:"实现一个简单类加载器"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#实现一个简单类加载器"}},[a._v("#")]),a._v(" 实现一个简单类加载器 *")]),a._v(" "),v("h4",{attrs:{id:"spring-与-classloader"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#spring-与-classloader"}},[a._v("#")]),a._v(" Spring 与 ClassLoader *")]),a._v(" "),v("h3",{attrs:{id:"模块化java"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#模块化java"}},[a._v("#")]),a._v(" 模块化Java *")]),a._v(" "),v("h2",{attrs:{id:"第六章-类文件结构"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#第六章-类文件结构"}},[a._v("#")]),a._v(" 第六章：类文件结构")]),a._v(" "),v("blockquote",[v("p",[a._v("Java技术在发展之初，设计者们就曾经考虑过并实现了让其他语言运行在Java虚拟机之上的可能")])]),a._v(" "),v("p",[a._v("JVM只与Class文件绑定，也就是说任何一门语言只要能表示为能被JVM接受的Class文件，均可以运行在JVM之上")]),a._v(" "),v("h3",{attrs:{id:"class文件结构"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#class文件结构"}},[a._v("#")]),a._v(" Class文件结构")]),a._v(" "),v("p",[a._v("下面以JDK 11为例，使用"),v("code",[a._v("javac")]),a._v("编译下面的代码")]),a._v(" "),v("div",{staticClass:"language-java line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-java"}},[v("code",[v("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),v("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("class")]),a._v(" "),v("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("User")]),a._v(" "),v("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n\n    "),v("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("private")]),a._v(" "),v("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("String")]),a._v(" username"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n\n    "),v("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),v("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("void")]),a._v(" "),v("span",{pre:!0,attrs:{class:"token function"}},[a._v("setUsername")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),v("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("String")]),a._v(" username"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n        "),v("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("this")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("username "),v("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" username"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    "),v("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n\n"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])]),a._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[a._v("1")]),v("br"),v("span",{staticClass:"line-number"},[a._v("2")]),v("br"),v("span",{staticClass:"line-number"},[a._v("3")]),v("br"),v("span",{staticClass:"line-number"},[a._v("4")]),v("br"),v("span",{staticClass:"line-number"},[a._v("5")]),v("br"),v("span",{staticClass:"line-number"},[a._v("6")]),v("br"),v("span",{staticClass:"line-number"},[a._v("7")]),v("br"),v("span",{staticClass:"line-number"},[a._v("8")]),v("br"),v("span",{staticClass:"line-number"},[a._v("9")]),v("br")])]),v("p",[a._v("使用十六进制编辑器打开生成的Class文件")]),a._v(" "),v("img",{staticStyle:{zoom:"50%"},attrs:{src:t(617)}}),a._v(" "),v("hr"),a._v(" "),v("p",[a._v("Class文件以8个字节为基础单位，按照高位在前（Big-Endian），由"),v("code",[a._v("无符号数")]),a._v("和"),v("code",[a._v("表")]),a._v("组成，其中"),v("code",[a._v("表")]),a._v("由多个"),v("code",[a._v("无符号数")]),a._v("或其他"),v("code",[a._v("表")]),a._v("组成，Class整个文件也可以视作一张表")]),a._v(" "),v("p",[a._v("下面以"),v("code",[a._v("u1")]),a._v("/"),v("code",[a._v("u2")]),a._v("/"),v("code",[a._v("u4")]),a._v("/"),v("code",[a._v("u8")]),a._v("分别代表1/2/4/8个字节的无符号数")]),a._v(" "),v("h4",{attrs:{id:"class文件头"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#class文件头"}},[a._v("#")]),a._v(" class文件头")]),a._v(" "),v("p",[a._v("class文件头固定以一个u4魔数"),v("code",[a._v("0xCAFEBABE")]),a._v("开头，便于其他程序识别这是一个Class文件")]),a._v(" "),v("p",[a._v("随后是一个u4的Class文件版本号，低位u2是次版本号（从Java 1.2起均为0），高位u2是主版本号（JDK 6对应50，每升一个大版本则加1）")]),a._v(" "),v("h4",{attrs:{id:"常量池"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#常量池"}},[a._v("#")]),a._v(" 常量池")]),a._v(" "),v("p",[a._v("在版本号后是常量池入口，开头为u2的容量计数器（值从1而非0开始，例如上图中计数器值为0x13，代表有0x12个常量）")]),a._v(" "),v("p",[a._v("使用"),v("code",[a._v("javap -verbose User")]),a._v("可以看到其中的常量池")]),a._v(" "),v("img",{staticStyle:{zoom:"50%"},attrs:{src:t(618)}}),a._v(" "),v("h4",{attrs:{id:"访问标志"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#访问标志"}},[a._v("#")]),a._v(" 访问标志")]),a._v(" "),v("p",[a._v("常量池结束后，紧跟着一个u2的访问标志，用来表明这个Class是类还是接口/枚举/注解、是否定义为public、是否定义为abstract/final等")]),a._v(" "),v("h4",{attrs:{id:"类索引、父类索引和接口索引集合"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#类索引、父类索引和接口索引集合"}},[a._v("#")]),a._v(" 类索引、父类索引和接口索引集合")]),a._v(" "),v("table",[v("thead",[v("tr",[v("th",[a._v("大小")]),a._v(" "),v("th",[a._v("内容")])])]),a._v(" "),v("tbody",[v("tr",[v("td",[a._v("u2")]),a._v(" "),v("td",[a._v("类索引，指向常量池中CONSTANT_Class_info的常量")])]),a._v(" "),v("tr",[v("td",[a._v("u2")]),a._v(" "),v("td",[a._v("父类索引（除Object类外均不可为0），指向常量池中CONSTANT_Class_info的常量")])]),a._v(" "),v("tr",[v("td",[a._v("u2")]),a._v(" "),v("td",[a._v("接口计数器")])]),a._v(" "),v("tr",[v("td",[a._v("u2 * n")]),a._v(" "),v("td",[a._v("接口索引")])])])]),a._v(" "),v("h4",{attrs:{id:"字段表集合"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#字段表集合"}},[a._v("#")]),a._v(" 字段表集合")]),a._v(" "),v("p",[a._v("用于描述接口或者类中声明的变量（不包含方法内部的局部变量）")]),a._v(" "),v("p",[a._v("首先是一个u2作为容量计数器n，随后跟上n个字段")]),a._v(" "),v("p",[a._v("每个字段表结构如下")]),a._v(" "),v("table",[v("thead",[v("tr",[v("th",[a._v("大小")]),a._v(" "),v("th",[a._v("内容")])])]),a._v(" "),v("tbody",[v("tr",[v("td",[a._v("u2")]),a._v(" "),v("td",[a._v("access_flags")])]),a._v(" "),v("tr",[v("td",[a._v("u2")]),a._v(" "),v("td",[a._v("name_index：指向一个Utf8类型的常量")])]),a._v(" "),v("tr",[v("td",[a._v("u2")]),a._v(" "),v("td",[a._v('descriptor_id：指向一个Utf8类型的常量（用来声明类型，如int则为"I"）')])]),a._v(" "),v("tr",[v("td",[a._v("u2")]),a._v(" "),v("td",[a._v("属性表计数")])]),a._v(" "),v("tr",[v("td",[a._v("不固定")]),a._v(" "),v("td",[a._v("属性表")])])])]),a._v(" "),v("h4",{attrs:{id:"方法表"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#方法表"}},[a._v("#")]),a._v(" 方法表 *")]),a._v(" "),v("p",[a._v("因为一些特殊的原因（计划被打乱了），此节暂时跳过")]),a._v(" "),v("h4",{attrs:{id:"属性表"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#属性表"}},[a._v("#")]),a._v(" 属性表 *")]),a._v(" "),v("p",[a._v("因为一些特殊的原因（计划被打乱了），此节暂时跳过")]),a._v(" "),v("h5",{attrs:{id:"code属性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#code属性"}},[a._v("#")]),a._v(" Code属性 *")]),a._v(" "),v("h2",{attrs:{id:"后记"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#后记"}},[a._v("#")]),a._v(" 后记")]),a._v(" "),v("p",[a._v("因为一些"),v("strong",[a._v("特殊原因")]),a._v("，去学C++了，这篇笔记先暂时放下，"),v("s",[a._v("或许某天会补完？")])])])}),[],!1,null,null,null);s.default=_.exports}}]);