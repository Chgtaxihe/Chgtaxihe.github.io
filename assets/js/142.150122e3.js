(window.webpackJsonp=window.webpackJsonp||[]).push([[142],{756:function(t,a,s){"use strict";s.r(a);var r=s(30),e=Object(r.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"协议"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#协议"}},[t._v("#")]),t._v(" 协议")]),t._v(" "),s("h3",{attrs:{id:"xti与sockets"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#xti与sockets"}},[t._v("#")]),t._v(" XTI与Sockets")]),t._v(" "),s("p",[t._v("XTI与Socket都是进行网络通信通信的接口")]),t._v(" "),s("p",[t._v("XTI (X/Open Transport Interface) 是一个协议无关的通信接口")]),t._v(" "),s("p",[t._v("Sockets(Berkeley sockets)")]),t._v(" "),s("p",[t._v("参考：https://en.wikipedia.org/wiki/X/Open_Transport_Interface")]),t._v(" "),s("h3",{attrs:{id:"sctp"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#sctp"}},[t._v("#")]),t._v(" SCTP")]),t._v(" "),s("h3",{attrs:{id:"tcp握手时-为什么需要协商序号-而不是从0开始"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#tcp握手时-为什么需要协商序号-而不是从0开始"}},[t._v("#")]),t._v(" TCP握手时，为什么需要协商序号（而不是从0开始？）")]),t._v(" "),s("h3",{attrs:{id:"tcp-time-wait"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#tcp-time-wait"}},[t._v("#")]),t._v(" TCP TIME_WAIT")]),t._v(" "),s("p",[t._v("为何是主动关闭连接的一方进入TimeWait")]),t._v(" "),s("h3",{attrs:{id:"为何要丢弃icmp"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#为何要丢弃icmp"}},[t._v("#")]),t._v(" 为何要丢弃ICMP？")]),t._v(" "),s("h3",{attrs:{id:"路径mtu的应用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#路径mtu的应用"}},[t._v("#")]),t._v(" 路径MTU的应用")]),t._v(" "),s("h3",{attrs:{id:"内核为任意一个监听套接字维护2个队列"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#内核为任意一个监听套接字维护2个队列"}},[t._v("#")]),t._v(" 内核为任意一个监听套接字维护2个队列")]),t._v(" "),s("h3",{attrs:{id:"当发送服务器fin且得到ack后-客户端仍可向socket中write数据"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#当发送服务器fin且得到ack后-客户端仍可向socket中write数据"}},[t._v("#")]),t._v(" 当发送服务器FIN且得到ACK后，客户端仍可向socket中write数据？")]),t._v(" "),s("h3",{attrs:{id:"tcp-低水位标记"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#tcp-低水位标记"}},[t._v("#")]),t._v(" TCP 低水位标记")]),t._v(" "),s("p",[t._v("只影响select，不影响write/read？")]),t._v(" "),s("h3",{attrs:{id:"带外数据"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#带外数据"}},[t._v("#")]),t._v(" 带外数据")]),t._v(" "),s("h3",{attrs:{id:"能不能手动发送一个fin-使得tcp成为-单向-通道并保持"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#能不能手动发送一个fin-使得tcp成为-单向-通道并保持"}},[t._v("#")]),t._v(" 能不能手动发送一个FIN，使得TCP成为“单向”通道并保持？")]),t._v(" "),s("h3",{attrs:{id:"tcp缓冲区大小与-带宽-延迟积-的关系-长胖管道"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#tcp缓冲区大小与-带宽-延迟积-的关系-长胖管道"}},[t._v("#")]),t._v(" TCP缓冲区大小与“带宽-延迟积”的关系（长胖管道？）")]),t._v(" "),s("h3",{attrs:{id:"udp没有发送缓冲区"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#udp没有发送缓冲区"}},[t._v("#")]),t._v(" UDP没有发送缓冲区？")]),t._v(" "),s("h3",{attrs:{id:"so-reuseaddr-的应用场景"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#so-reuseaddr-的应用场景"}},[t._v("#")]),t._v(" SO_REUSEADDR 的应用场景")]),t._v(" "),s("h3",{attrs:{id:"若创建了在ipv6上监听socket-则无需在同一端口上创建ipv4的socket"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#若创建了在ipv6上监听socket-则无需在同一端口上创建ipv4的socket"}},[t._v("#")]),t._v(" 若创建了在IPV6上监听socket，则无需在同一端口上创建IPV4的socket？")]),t._v(" "),s("p",[t._v("UNP P250")]),t._v(" "),s("h2",{attrs:{id:"c"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#c"}},[t._v("#")]),t._v(" C++")]),t._v(" "),s("h3",{attrs:{id:"将socketaddr-in强制转换为socketaddr"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#将socketaddr-in强制转换为socketaddr"}},[t._v("#")]),t._v(" 将socketaddr_in强制转换为socketaddr")]),t._v(" "),s("p",[t._v("在C++中定义struct，内部属性在内存中的顺序严格按照定义时的顺序吗")]),t._v(" "),s("h3",{attrs:{id:"c中返回char指针的函数-其数据保存在哪里"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#c中返回char指针的函数-其数据保存在哪里"}},[t._v("#")]),t._v(" C中返回char指针的函数，其数据保存在哪里？")]),t._v(" "),s("p",[t._v("（可重入函数/不可重入函数）")]),t._v(" "),s("h2",{attrs:{id:"linux"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#linux"}},[t._v("#")]),t._v(" Linux")]),t._v(" "),s("h3",{attrs:{id:"fork后-文件描述符由2个进程共同持有-那close会如何"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#fork后-文件描述符由2个进程共同持有-那close会如何"}},[t._v("#")]),t._v(" fork后，文件描述符由2个进程共同持有？那close会如何？")]),t._v(" "),s("p",[t._v("每个文件/socket都有引用计数")]),t._v(" "),s("h3",{attrs:{id:"errno-eintr"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#errno-eintr"}},[t._v("#")]),t._v(" errno == EINTR")]),t._v(" "),s("p",[t._v("为什么不能异步/并行处理中断？非得打断系统调用。。")]),t._v(" "),s("h3",{attrs:{id:"select在eintr后自动重启-计时器归零还是保持之前的状态"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#select在eintr后自动重启-计时器归零还是保持之前的状态"}},[t._v("#")]),t._v(" select在EINTR后自动重启，计时器归零还是保持之前的状态？")]),t._v(" "),s("h3",{attrs:{id:"select中的fd-set只有1024位-那是不是意味着使用select的进程最多只能同时处理1024个fd"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#select中的fd-set只有1024位-那是不是意味着使用select的进程最多只能同时处理1024个fd"}},[t._v("#")]),t._v(" select中的fd_set只有1024位，那是不是意味着使用select的进程最多只能同时处理1024个fd？")]),t._v(" "),s("h3",{attrs:{id:"更进一步的-fork以后fd不变-是不是意味着fd是系统级的-一个fd值在整个系统只能一个"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#更进一步的-fork以后fd不变-是不是意味着fd是系统级的-一个fd值在整个系统只能一个"}},[t._v("#")]),t._v(" 更进一步的，fork以后fd不变，是不是意味着fd是系统级的（一个fd值在整个系统只能一个）")]),t._v(" "),s("h3",{attrs:{id:"select每次返回-fd-set中只会有一个bit被置1吗"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#select每次返回-fd-set中只会有一个bit被置1吗"}},[t._v("#")]),t._v(" select每次返回，fd_set中只会有一个bit被置1吗")]),t._v(" "),s("h3",{attrs:{id:"getaddrinfo返回的链表-内存是怎么分配的-又是怎么删除的"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#getaddrinfo返回的链表-内存是怎么分配的-又是怎么删除的"}},[t._v("#")]),t._v(" getaddrinfo返回的链表，内存是怎么分配的？又是怎么删除的？")]),t._v(" "),s("p",[t._v("通过malloc，因此需要调用"),s("code",[t._v("freeaddrinfo")])])])}),[],!1,null,null,null);a.default=e.exports}}]);